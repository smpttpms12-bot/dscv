<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DS Code Vault</title>

  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      background: #000000;
      color: #121111;
      margin: 0;
      padding: 30px;
    }

    h1 {
      text-align: center;
      margin-bottom: 30px;
    }

    .container {
      max-width: 900px;
      margin: auto;
    }

    .card {
      background: #000000;
      border: 1px solid #000000;
      border-radius: 10px;
      padding: 16px 20px;
      margin-bottom: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .title {
      font-size: 15px;
      line-height: 1.4;
      width: 75%;
    }

    button {
      background: #000000;
      border: none;
      color: #1b1a1a;
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    }

    button:hover {
      background: #000000;
    }

    footer {
      text-align: center;
      margin-top: 40px;
      font-size: 13px;
      color: #000000;
    }
  </style>
</head>

<body>

  <h1> Data Structures Code Vault</h1>

  <div class="container">
    <ol style="padding-left:20px">

      <li><div class="card"><div class="title">Searching Methods (Linear & Binary)</div><button onclick="copyCode('code1')">Copy</button></div></li>
      <li><div class="card"><div class="title">Sorting Methods (Bubble & Insertion)</div><button onclick="copyCode('code2')">Copy</button></div></li>
      <li><div class="card"><div class="title">Singly Linked List</div><button onclick="copyCode('code3')">Copy</button></div></li>
      <li><div class="card"><div class="title">Doubly Linked List</div><button onclick="copyCode('code4')">Copy</button></div></li>
      <li><div class="card"><div class="title">Circular Linked List</div><button onclick="copyCode('code5')">Copy</button></div></li>
      <li><div class="card"><div class="title">Stack using Singly Linked List</div><button onclick="copyCode('code6')">Copy</button></div></li>
      <li><div class="card"><div class="title">Stack using Doubly Linked List</div><button onclick="copyCode('code7')">Copy</button></div></li>
      <li><div class="card"><div class="title">Stack using Circular Linked List</div><button onclick="copyCode('code8')">Copy</button></div></li>
      <li><div class="card"><div class="title">Stack using Array</div><button onclick="copyCode('code9')">Copy</button></div></li>
      <li><div class="card"><div class="title">Queue using Stack</div><button onclick="copyCode('code10')">Copy</button></div></li>
      <li><div class="card"><div class="title">Find First n integers 1 2 3</div><button onclick="copyCode('codea')">Copy</button></div></li>
      <li><div class="card"><div class="title">Queue using Singly Linked List</div><button onclick="copyCode('code11')">Copy</button></div></li>
      <li><div class="card"><div class="title">Queue using Doubly Linked List</div><button onclick="copyCode('code12')">Copy</button></div></li>
      <li><div class="card"><div class="title">Queue using Circular Linked List</div><button onclick="copyCode('code13')">Copy</button></div></li>
      <li><div class="card"><div class="title">Queue using Array</div><button onclick="copyCode('code14')">Copy</button></div></li>
      <li><div class="card"><div class="title">Binary Tree</div><button onclick="copyCode('code15')">Copy</button></div></li>
      <li><div class="card"><div class="title">Binary Search Tree</div><button onclick="copyCode('code16')">Copy</button></div></li>
      <li><div class="card"><div class="title">Graph Creation</div><button onclick="copyCode('code17')">Copy</button></div></li>
      <li><div class="card"><div class="title">Graph Traversal (BFS & DFS)</div><button onclick="copyCode('code18')">Copy</button></div></li>
      <li><div class="card"><div class="title">HashMap Frequency Count</div><button onclick="copyCode('code19')">Copy</button></div></li>

    </ol>
  </div>
    
  <footer>
    Upload to GitHub • Deploy with GitHub Pages • Codes Hidden by Design
  </footer>

  <script>
    const hiddenCodes = {

      code1: `#include <stdio.h>
int sorting(int arr[], int n) {
    int i,j;
    for (i = 0; i < n-1; i++) {
        for (j =0 ; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

int linearsearch(int arr[], int n, int key) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n- i - 1; j++) {
            if (key==arr[j]) {
                return j;
            }
        }
    }

}

int binarysearch(int arr[], int n, int key) {
    int i,j,low,high,mid;
    low = 0;
    high = n - 1;
    //printf("%d",mid);
    while (low<=high) {

        mid = (low + high) / 2;
        if (arr[mid] == key)
           return mid;
        if (arr[mid] < key)
            low = mid + 1;
        if (arr[mid]>key)
            high = mid - 1;

    }

}

int main() {
    int i, n, j, key;
    printf("Enter number of elements in array\n");
    scanf("%d", &n);
    int arr[n];
    printf("Enter array elements\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    printf("enter key\n");
    scanf("%d", &key);
    j=linearsearch(arr, n, key);
    printf("linear search result: %d index and %d th position\n", j, j+1);
    sorting(arr, n);
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    int result=binarysearch(arr, n, key);
    if (result == -1)
        printf("Element not found");
    else
        printf("Binary search result %d index and %d position", result, result+1);

    return 0;

}`,

      code2: `#include <stdio.h>



int swap (int *a, int *b) {
    int temp;
    temp= *a;
    *a= *b;
    *b= temp;
}
int heapify(int arr[], int n, int i) {
    int largest = i;
    int l= 2 * i +1;
    int r= 2 * i + 2;
    if (l < n && arr[l] > arr[largest]) {
        largest= l; }
    if (r < n && arr[r] > arr[largest]) {
        largest= r;
    }
    if (largest != i) {
        swap(&arr[i], &arr[largest]);

        heapify(arr, n, largest);
    }

}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i= low-1;
    for (int j=low; j<high; j++) {
        if (arr[j]<pivot)
            i++;
        swap(&arr[i], & arr[j]);
    }

    swap(&arr[i+1], &pivot);
    return i+1;
}
int bubblesort(int arr[], int n) {
    int i;
    for (i=0;i<n-1;i++) {
        for (int j=0; j<n-i-1; j++) {
            if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]);
        }
    }
    for (i=0; i<n; i++) {
        printf("%d ", arr[i]);
    }

}

int insertionsort(int arr[], int n) {
    int i,j;
    for (i=0; i<n; i++) {
        for (j=i+1; j<n-i-1; j++) {
            if (arr[j]< arr[j-1]) swap(&arr[j], &arr[j-1]);
        }

    }
    for (i=0; i<n; i++) {
        printf("%d ", arr[i]);
    }

}

int quicksort(int arr[], int low, int high) {
    if (low<high) {
        int pi= partition(arr, low, high);
        quicksort(arr, low, pi-1);
        quicksort(arr, pi+1, high);
    }

}
int heapsort(int arr[], int n) {
    for (int i= n/2 -1 ; i>=0; i--) {
        heapify(arr, n, i);
    }
    for (int i=n-1; i>0; i--) {
        int temp= arr[0];
        arr[0]= arr[i];
        arr[i]= temp;
        heapify(arr, i, 0);
    }
}

int selectionsort(int arr[], int n) {
    int i, j;
    for (i=0; i<=n-1; i++) {
        int min_idx= i;
        for (j=i+1; j<=n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx= j;
            }
        }
        swap(&arr[i], &arr[min_idx]);
    }

    }

int printarray(int arr[], int n) {
    for (int i=0; i<n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;
    printf("enter n\n");
    scanf("%d", &n);
    int arr[n];

    printf("\n");

    printf("enter numbers");
    for (int k=0; k<n; k++) {
        scanf("%d", &arr[k]);
    }
    printf("bubblesort");
    bubblesort(arr, n);

    printf("insertion sort");
    insertionsort(arr, n);

    printf("Quicksort sort");
    quicksort(arr,0, n-1);
    for (int i=0 ; i<n; i++) {
        printf("%d ", arr[i]);
    }
    printf(" heapsort\n");
    heapsort(arr, n);

    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);

    selectionsort(arr, n);

    printf("Selectinsort\n ");
    printarray(arr, n);
}`,

      code3: `
#include <stdlib.h>
#include <stdio.h>

/* ---------- Node Definition ---------- */
typedef struct Node {
    int data;
    struct Node* next;
} Node;

/* ---------- Create New Node ---------- */
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

/* ---------- Print Linked List ---------- */
void printList(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL
");
}

/* ---------- Find Size ---------- */
int size(Node* head) {
    int count = 0;
    while (head != NULL) {
        count++;
        head = head->next;
    }
    return count;
}

/* ---------- Print Kth Node ---------- */
void printKth(Node* head, int k) {
    int count = 1;
    while (head != NULL) {
        if (count == k) {
            printf("Kth Node (%d): %d
", k, head->data);
            return;
        }
        count++;
        head = head->next;
    }
    printf("Kth node not found
");
}

/* ---------- Search Value ---------- */
void search(Node* head, int x) {
    while (head != NULL) {
        if (head->data == x) {
            printf("Value %d found
", x);
            return;
        }
        head = head->next;
    }
    printf("Value %d not found
", x);
}

/* ---------- Print Reverse (Recursion) ---------- */
void printReverse(Node* head) {
    if (head == NULL)
        return;
    printReverse(head->next);
    printf("%d -> ", head->data);
}

/* ---------- Insert at Beginning ---------- */
Node* insertBegin(Node* head, int x) {
    Node* newNode = createNode(x);
    newNode->next = head;
    return newNode;
}

/* ---------- Insert at End ---------- */
Node* insertEnd(Node* head, int x) {
    Node* newNode = createNode(x);
    if (head == NULL)
        return newNode;
    Node* temp = head;
    while (temp->next != NULL)
        temp = temp->next;
    temp->next = newNode;
    return head;
}

/* ---------- Insert at Position p ---------- */
Node* insertAtPos(Node* head, int x, int p) {
    if (p == 1)
        return insertBegin(head, x);

    Node* temp = head;
    for (int i = 1; i < p - 1 && temp != NULL; i++)
        temp = temp->next;

    if (temp == NULL) {
        printf("Invalid position
");
        return head;
    }

    Node* newNode = createNode(x);
    newNode->next = temp->next;
    temp->next = newNode;
    return head;
}

/* ---------- Insert in Middle ---------- */
Node* insertMiddle(Node* head, int x) {
    int mid = size(head) / 2 + 1;
    return insertAtPos(head, x, mid);
}

/* ---------- Delete Beginning ---------- */
Node* deleteBegin(Node* head) {
    if (head == NULL)
        return NULL;
    Node* temp = head;
    head = head->next;
    free(temp);
    return head;
}

/* ---------- Delete End ---------- */
Node* deleteEnd(Node* head) {
    if (head == NULL || head->next == NULL)
        return deleteBegin(head);

    Node* temp = head;
    while (temp->next->next != NULL)
        temp = temp->next;

    free(temp->next);
    temp->next = NULL;
    return head;
}

/* ---------- Delete at Position ---------- */
Node* deleteAtPos(Node* head, int p) {
    if (p == 1)
        return deleteBegin(head);

    Node* temp = head;
    for (int i = 1; i < p - 1 && temp != NULL; i++)
        temp = temp->next;

    if (temp == NULL || temp->next == NULL) {
        printf("Invalid position
");
        return head;
    }

    Node* del = temp->next;
    temp->next = del->next;
    free(del);
    return head;
}

/* ---------- Delete Middle ---------- */
Node* deleteMiddle(Node* head) {
    int mid = size(head) / 2 + 1;
    return deleteAtPos(head, mid);
}

/* ---------- Delete by Value ---------- */
Node* deleteByValue(Node* head, int x) {
    if (head == NULL)
        return NULL;

    if (head->data == x)
        return deleteBegin(head);

    Node* temp = head;
    while (temp->next != NULL && temp->next->data != x)
        temp = temp->next;

    if (temp->next == NULL) {
        printf("Value not found
");
        return head;
    }

    Node* del = temp->next;
    temp->next = del->next;
    free(del);
    return head;
}

/* ---------- MAIN FUNCTION ---------- */
int main() {
    Node* head = NULL;

    /* i) Creation of Linked List with 7 nodes */
    for (int i = 1; i <= 7; i++)
        head = insertEnd(head, i * 10);
    printf("Initial List:
");
    printList(head);

    /* ii) Size */
    printf("Size: %d
", size(head));

    /* iii) Kth Node */
    printKth(head, 3);

    /* iv) Search */
    search(head, 40);

    /* v) Reverse Print */
    printf("Reverse Order:
");
    printReverse(head);
    printf("NULL
");

    /* vi) Insert Beginning */
    head = insertBegin(head, 5);
    printList(head);

    /* vii) Insert Middle */
    head = insertMiddle(head, 25);
    printList(head);

    /* viii) Insert at Position */
    head = insertAtPos(head, 99, 4);
    printList(head);

    /* ix) Insert End */
    head = insertEnd(head, 80);
    printList(head);

    /* x) Delete Beginning */
    head = deleteBegin(head);
    printList(head);

    /* xi) Delete Middle */
    head = deleteMiddle(head);
    printList(head);

    /* xii) Delete by Value */
    head = deleteByValue(head, 50);
    printList(head);

    /* xiii) Delete at Position */
    head = deleteAtPos(head, 3);
    printList(head);

    /* xiv) Delete Last */
    head = deleteEnd(head);
    printList(head);

    return 0;
}
`,

      code4: `
#include<stdio.h>
#include<stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
    struct Node *prev;
}Node;

Node* createnode(int data) {
    Node* newnode= (Node*)malloc(sizeof(Node));
    newnode-> data = data;
    newnode-> next = NULL;
    newnode->prev = NULL;
    return newnode;
}

void printlist(Node* head) {
    Node* temp=head;
    printf("\n");
    printf("NULL <->");
    while(temp!=NULL) {
        printf("%d <-> ",temp->data);
        temp=temp->next;
    }
    printf("NULL \n");
}

void printreverse(Node* head) {
    Node* temp=head;
    if(head==NULL) {
        return;
    }
    while (temp-> next!= NULL) {
        temp=temp->next;
    }
    printf("NULL <-> ");
    while(temp!=NULL) {
        printf("%d <-> ",temp->data);
        temp= temp-> prev;
    }
    printf("NULL \n");
}
Node* insertbegin(Node* head, int data) {
    Node* newnode= createnode(data);
    newnode->next= head;
    newnode->prev= NULL;
    if (head!=NULL) {
        head->prev= newnode;
    }
    head= newnode;
    return head;
}
int size(Node* head) {
    int count=0;
    while (head!= NULL) {
        count++;
        head = head->next;
    }
    return count;
}
Node* insertend(Node* head) {
    Node* temp= head;
    Node* newnode= createnode(10);
    while (temp-> next!=NULL) {
        temp= temp->next;
    }
    temp->next= newnode;
    newnode->prev= temp;
    return head;
}
Node* insertposition(Node* head, int data, int pos) {
    if (pos==1) {
        head= insertbegin(head, data);
        return head;
    }
    Node* newnode= createnode(data);
    Node* temp= head;

        for (int i=1; i<pos-1 && temp!= NULL; i++) {
            temp= temp->next;
        }
    if (temp== NULL) {
        printf("position Not Found");
        return head;
    }
    newnode->next= temp-> next;
        temp->next= newnode;
        newnode->prev= temp;

        temp->next->prev=newnode;
        return head;


}
Node* insertmiddle(Node* head, int data) {
    Node* newnode= createnode(data);
    int mid= size(head)/2 +1;
    head= insertposition(head,data,mid);
    return head;
}

Node* deletebegin(Node* head) {
    Node* temp= head;
    if (head==NULL) {
        return NULL;
    }
    head= head->next;
    free(temp);
    return head;

}
Node* deleteend(Node* head) {
    Node* temp= head;
    if (head==NULL) {
        return NULL;
    }
    while (temp->next!=NULL) {
        temp= temp->next;
    }
    temp->prev->next= NULL;
    free(temp);
    return head;
}
Node* deletepos(Node* head, int pos) {
    if (pos==1)
        return deletebegin(head);
    Node* temp= head;
    for (int i=1; i<pos-1 && temp!= NULL; i++) {
        temp= temp->next;
    }
    if (temp == NULL) {
        printf("position Not Found");
        return head;
    }
    /*if (temp->prev!=NULL) {
        temp->prev->next= temp->next;
    }
    if (temp->next!= NULL)
    {   temp->next->prev= temp->prev;}
    free(temp);
    return head;*/
    Node* del= temp->next;
    temp->next= del->next;
    free(del);
    return head;
}
Node* deletemiddle(Node* head) {
    int mid= size(head)/2 +1;
    head= deletepos(head, mid);
    return head;
}
Node* deleteval(Node* head, int val) {
    if (head==NULL) {
        return NULL;
    }
    if (head->data == val) {
        return deletebegin(head);
    }
    Node* temp= head;
    while (temp!= NULL && temp->next->data != val) {

    temp= temp->next;}

    if (temp==NULL) {
        printf("Data Not Found");
        return head;
    }
    Node* del= temp->next;
    temp->next= del->next;
    free(del);
    return head;


}
int main() {
    Node* head = NULL;
    head = createnode(10);
    Node* n1 = createnode(20);
    Node* n2 = createnode(30);
    Node* n3 = createnode(40);
    Node* n4 = createnode(50);
    head->next = n1;
    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    head->prev= NULL;
    n1->prev= head;
    n2->prev= n1;
    n3->prev= n2;
    n4->prev= n3;
    printlist(head);

    printreverse(head);

    int c= size(head);
    printf("The size of the list is %d\n", c);

    printf("insert at begining");
    head= insertbegin(head, 90);
    printlist(head);
    printf("\n ");

    printf("insert at end");
    head= insertend(head);
    printlist(head);
    printf("\n ");

    printf("insert at position");
    head= insertposition(head, 100, 4);

    printlist(head);
    printf("\n ");

    printf("insert at middle");
    head= insertmiddle(head, 1);
    printlist(head);
    printf("\n ");

    printf("delete  at beginning");
    head= deletebegin(head);
    printlist(head);
    printf("\n ");

    printf("delete at end");
    head= deleteend(head);
    printlist(head);
    printf("\n ");

    printf("delete at position");
    head= deletepos(head, 4);
    printlist(head);
    printf("\n ");

    printf("delete at middle");
    head= deletemiddle(head);
    printlist(head);
    printf("\n ");

    printf("delete by value");
    head= deleteval(head, 100);
    printlist(head);
    printf("\n ");
}`,

      code5: `
/* ====================================================
   FULL CODE: CIRCULAR SINGLY LINKED LIST (CSLL)
   ==================================================== */
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

Node* createnode(int data) {
    Node* newnode = (Node*)malloc(sizeof(Node));
    newnode->data = data;
    newnode->next = newnode; // Points to itself
    return newnode;
}

/* Helper for size */
int size(Node* head) {
    if (head == NULL) return 0;
    int count = 0;
    Node* temp = head;
    do {
        count++;
        temp = temp->next;
    } while (temp != head);
    return count;
}

void printlist(Node* head) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }
    Node* temp = head;
    printf("\nHEAD -> ");
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("HEAD (Circular)\n");
}

/* Recursive helper to print reverse in CSLL */
void printreverseHelper(Node* current, Node* head) {
    if (current->next == head) {
        printf("%d <-> ", current->data);
        return;
    }
    printreverseHelper(current->next, head);
    printf("%d <-> ", current->data);
}

void printreverse(Node* head) {
    if (head == NULL) return;
    printf("\nReverse: ");
    printreverseHelper(head, head);
    printf("HEAD\n");
}

Node* insertbegin(Node* head, int data) {
    Node* newnode = createnode(data);
    if (head == NULL) return newnode;

    Node* temp = head;
    while (temp->next != head) { // Find last node
        temp = temp->next;
    }
    
    newnode->next = head;
    temp->next = newnode;
    head = newnode; // Update head
    return head;
}

Node* insertend(Node* head) { // Using fixed value 10 as per your original code
    // Note: Converted to take parameter usually, but keeping your style
    Node* newnode = createnode(10); 
    if (head == NULL) return newnode;

    Node* temp = head;
    while (temp->next != head) {
        temp = temp->next;
    }
    temp->next = newnode;
    newnode->next = head;
    return head;
}

Node* insertposition(Node* head, int data, int pos) {
    if (pos == 1) return insertbegin(head, data);
    
    Node* newnode = createnode(data);
    Node* temp = head;
    
    for (int i = 1; i < pos - 1; i++) {
        temp = temp->next;
        if (temp == head) { // Safety check
            printf("Position Not Found\n");
            return head;
        }
    }
    
    newnode->next = temp->next;
    temp->next = newnode;
    return head;
}

Node* insertmiddle(Node* head, int data) {
    int mid = size(head) / 2 + 1;
    head = insertposition(head, data, mid);
    return head;
}

Node* deletebegin(Node* head) {
    if (head == NULL) return NULL;
    
    Node* temp = head;
    if (head->next == head) { // Single node
        free(head);
        return NULL;
    }
    
    Node* last = head;
    while (last->next != head) {
        last = last->next;
    }
    
    head = head->next;
    last->next = head;
    free(temp);
    return head;
}

Node* deleteend(Node* head) {
    if (head == NULL) return NULL;
    if (head->next == head) {
        free(head);
        return NULL;
    }
    
    Node* temp = head;
    Node* prev = NULL;
    while (temp->next != head) {
        prev = temp;
        temp = temp->next;
    }
    
    prev->next = head;
    free(temp);
    return head;
}

Node* deletepos(Node* head, int pos) {
    if (head == NULL) return NULL;
    if (pos == 1) return deletebegin(head);
    
    Node* temp = head;
    Node* prev = NULL;
    
    for (int i = 1; i < pos; i++) {
        prev = temp;
        temp = temp->next;
        if (temp == head) {
            printf("Position Not Found\n");
            return head;
        }
    }
    
    prev->next = temp->next;
    free(temp);
    return head;
}

Node* deletemiddle(Node* head) {
    if (head == NULL) return NULL;
    int mid = size(head) / 2 + 1;
    return deletepos(head, mid);
}

Node* deleteval(Node* head, int val) {
    if (head == NULL) return NULL;
    if (head->data == val) return deletebegin(head);
    
    Node* temp = head;
    Node* prev = NULL;
    
    do {
        prev = temp;
        temp = temp->next;
        if (temp->data == val) {
            prev->next = temp->next;
            free(temp);
            return head;
        }
    } while (temp != head);
    
    printf("Data Not Found\n");
    return head;
}

int main() {
    printf("=== TESTING CSLL ===\n");
    Node* head = NULL;
    head = createnode(10);
    Node* n1 = createnode(20);
    Node* n2 = createnode(30);
    Node* n3 = createnode(40);
    Node* n4 = createnode(50);
    
    // Manual Linking for CSLL
    head->next = n1;
    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = head; // Close circle

    printlist(head);
    printreverse(head);

    int c = size(head);
    printf("The size of the list is %d\n", c);

    printf("insert at begining (90)");
    head = insertbegin(head, 90);
    printlist(head);

    printf("insert at end (10)");
    head = insertend(head);
    printlist(head);

    printf("insert at position (100 at 4)");
    head = insertposition(head, 100, 4);
    printlist(head);

    printf("insert at middle (1)");
    head = insertmiddle(head, 1);
    printlist(head);

    printf("delete at beginning");
    head = deletebegin(head);
    printlist(head);

    printf("delete at end");
    head = deleteend(head);
    printlist(head);

    printf("delete at position (4)");
    head = deletepos(head, 4);
    printlist(head);

    printf("delete at middle");
    head = deletemiddle(head);
    printlist(head);

    printf("delete by value (100)");
    head = deleteval(head, 100);
    printlist(head);
}
    
/* ====================================================
   FULL CODE: CIRCULAR DOUBLY LINKED LIST (CDLL)
   ==================================================== */
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
    struct Node *prev;
} Node;

Node* createnode(int data) {
    Node* newnode = (Node*)malloc(sizeof(Node));
    newnode->data = data;
    newnode->next = newnode; // Points to self
    newnode->prev = newnode; // Points to self
    return newnode;
}

/* Helper for size */
int size(Node* head) {
    if (head == NULL) return 0;
    int count = 0;
    Node* temp = head;
    do {
        count++;
        temp = temp->next;
    } while (temp != head);
    return count;
}

void printlist(Node* head) {
    if (head == NULL) {
        printf("List is empty\n");
        return;
    }
    Node* temp = head;
    printf("\nHEAD <-> ");
    do {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("HEAD (Circular)\n");
}

void printreverse(Node* head) {
    if (head == NULL) return;
    
    Node* temp = head->prev; // Start at the last node!
    printf("\nReverse: TAIL <-> ");
    do {
        printf("%d <-> ", temp->data);
        temp = temp->prev;
    } while (temp != head->prev);
    printf("TAIL\n");
}

Node* insertbegin(Node* head, int data) {
    Node* newnode = createnode(data);
    if (head == NULL) return newnode;

    Node* last = head->prev; // Direct access to tail

    newnode->next = head;
    newnode->prev = last;
    
    last->next = newnode;
    head->prev = newnode;
    
    head = newnode;
    return head;
}

Node* insertend(Node* head) { // Using fixed value 10 per your code
    Node* newnode = createnode(10);
    if (head == NULL) return newnode;

    Node* last = head->prev;

    newnode->next = head;
    newnode->prev = last;
    
    last->next = newnode;
    head->prev = newnode;
    
    return head;
}

Node* insertposition(Node* head, int data, int pos) {
    if (pos == 1) return insertbegin(head, data);
    
    Node* temp = head;
    for (int i = 1; i < pos - 1; i++) {
        temp = temp->next;
        if (temp == head) {
            printf("position Not Found");
            return head;
        }
    }
    
    Node* newnode = createnode(data);
    // temp is node BEFORE, temp->next is node AFTER
    
    newnode->next = temp->next;
    newnode->prev = temp;
    
    temp->next->prev = newnode;
    temp->next = newnode;
    
    return head;
}

Node* insertmiddle(Node* head, int data) {
    int mid = size(head) / 2 + 1;
    head = insertposition(head, data, mid);
    return head;
}

Node* deletebegin(Node* head) {
    if (head == NULL) return NULL;
    
    if (head->next == head) { // Single node
        free(head);
        return NULL;
    }
    
    Node* last = head->prev;
    Node* temp = head;
    
    head = head->next;
    
    head->prev = last;
    last->next = head;
    
    free(temp);
    return head;
}

Node* deleteend(Node* head) {
    if (head == NULL) return NULL;
    if (head->next == head) {
        free(head);
        return NULL;
    }
    
    Node* last = head->prev;
    Node* newlast = last->prev;
    
    newlast->next = head;
    head->prev = newlast;
    
    free(last);
    return head;
}

Node* deletepos(Node* head, int pos) {
    if (head == NULL) return NULL;
    if (pos == 1) return deletebegin(head);
    
    Node* temp = head;
    for (int i = 1; i < pos; i++) {
        temp = temp->next;
        if (temp == head) {
            printf("position Not Found");
            return head;
        }
    }
    
    // temp is the node to delete
    temp->prev->next = temp->next;
    temp->next->prev = temp->prev;
    
    free(temp);
    return head;
}

Node* deletemiddle(Node* head) {
    if (head == NULL) return NULL;
    int mid = size(head) / 2 + 1;
    return deletepos(head, mid);
}

Node* deleteval(Node* head, int val) {
    if (head == NULL) return NULL;
    if (head->data == val) return deletebegin(head);
    
    Node* temp = head;
    do {
        if (temp->data == val) {
            temp->prev->next = temp->next;
            temp->next->prev = temp->prev;
            free(temp);
            return head;
        }
        temp = temp->next;
    } while (temp != head);
    
    printf("Data Not Found\n");
    return head;
}

int main() {
    printf("=== TESTING CDLL ===\n");
    Node* head = NULL;
    head = createnode(10);
    Node* n1 = createnode(20);
    Node* n2 = createnode(30);
    Node* n3 = createnode(40);
    Node* n4 = createnode(50);
    
    // Manual Linking for CDLL
    head->next = n1; n1->prev = head;
    n1->next = n2;   n2->prev = n1;
    n2->next = n3;   n3->prev = n2;
    n3->next = n4;   n4->prev = n3;
    
    // Closing the circle
    n4->next = head;
    head->prev = n4;

    printlist(head);
    printreverse(head);

    int c = size(head);
    printf("The size of the list is %d\n", c);

    printf("insert at begining (90)");
    head = insertbegin(head, 90);
    printlist(head);

    printf("insert at end (10)");
    head = insertend(head);
    printlist(head);

    printf("insert at position (100 at 4)");
    head = insertposition(head, 100, 4);
    printlist(head);

    printf("insert at middle (1)");
    head = insertmiddle(head, 1);
    printlist(head);

    printf("delete at beginning");
    head = deletebegin(head);
    printlist(head);

    printf("delete at end");
    head = deleteend(head);
    printlist(head);

    printf("delete at position (4)");
    head = deletepos(head, 4);
    printlist(head);

    printf("delete at middle");
    head = deletemiddle(head);
    printlist(head);

    printf("delete by value (100)");
    head = deleteval(head, 100);
    printlist(head);
}`,

      code6: `#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/* --- SLL NODE --- */
typedef struct Node {
    char data;
    struct Node* next;
} Node;

Node* top = NULL;

/* --- SLL STACK OPERATIONS --- */
int isEmpty() { return top == NULL; }

void push(char c) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = c;
    newNode->next = top;
    top = newNode;
}

char pop() {
    if (isEmpty()) return -1;
    Node* temp = top;
    char val = temp->data;
    top = top->next;
    free(temp);
    return val;
}

char peek() { return isEmpty() ? -1 : top->data; }
int full() { return malloc(sizeof(Node))==NULL; }

/* --- CONVERSION HELPERS --- */
int precedence(char c) {
    if (c == '^') return 3;
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return 0;
}

void reverse(char* exp) {
    int len = strlen(exp);
    for (int i = 0; i < len / 2; i++) {
        char temp = exp[i];
        exp[i] = exp[len - i - 1];
        exp[len - i - 1] = temp;
    }
}

/* --- INFIX TO POSTFIX --- */
void infixToPostfix(char* infix, char* output) {
    int i = 0, j = 0;
    while (infix[i] != '\0') {
        char c = infix[i];
        if (isalnum(c)) output[j++] = c;
        else if (c == '(') push(c);
        else if (c == ')') {
            while (!isEmpty() && peek() != '(') output[j++] = pop();
            pop(); // Remove '('
        } else {
            while (!isEmpty() && precedence(peek()) >= precedence(c)) output[j++] = pop();
            push(c);
        }
        i++;
    }
    while (!isEmpty()) output[j++] = pop();
    output[j] = '\0';
}

/* --- INFIX TO PREFIX --- */
void infixToPrefix(char* infix, char* output) {
    // 1. Reverse Infix
    reverse(infix);

    // 2. Swap ( and )
    for (int i = 0; infix[i] != '\0'; i++) {
        if (infix[i] == '(') infix[i] = ')';
        else if (infix[i] == ')') infix[i] = '(';
    }

    // 3. Get Postfix of the reversed string
    char temp[100];
    infixToPostfix(infix, temp);

    // 4. Reverse result to get Prefix
    reverse(temp);
    strcpy(output, temp);
}

/* --- MAIN --- */
int main() {
    char infix[100], postfix[100], prefix[100];

    // Reset Stack for safety
    top = NULL;

    printf("--- SLL STACK ---\n");
    printf("Enter Infix: ");
    scanf("%s", infix);

    // Calc Postfix
    top = NULL; // Clear stack
    infixToPostfix(infix, postfix);
    printf("Postfix: %s\n", postfix);

    // Calc Prefix (Note: infix string is modified by reverse, so we restore or re-scan)
    // For simplicity, re-entering or careful copying is needed.
    // Here we assume the user provides input again or we copy it:
    char infixCopy[100];
    strcpy(infixCopy, infix);

    top = NULL; // Clear stack
    infixToPrefix(infixCopy, prefix);
    printf("Prefix:  %s\n", prefix);

    return 0;
}`,

      code7: `#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/* --- DLL NODE --- */
typedef struct Node {
    char data;
    struct Node* next;
    struct Node* prev;
} Node;

Node* top = NULL;

/* --- DLL STACK OPERATIONS --- */
int isEmpty() { return top == NULL; }

void push(char c) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = c;
    newNode->next = top;
    newNode->prev = NULL;
    if (top != NULL) top->prev = newNode;
    top = newNode;
}

char pop() {
    if (isEmpty()) return -1;
    Node* temp = top;
    char val = temp->data;
    top = top->next;
    if (top != NULL) top->prev = NULL;
    free(temp);
    return val;
}

char peek() { return isEmpty() ? -1 : top->data; }

/* --- CONVERSION HELPERS --- */
int precedence(char c) {
    if (c == '^') return 3;
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return 0;
}

void reverse(char* exp) {
    int len = strlen(exp);
    for (int i = 0; i < len / 2; i++) {
        char temp = exp[i];
        exp[i] = exp[len - i - 1];
        exp[len - i - 1] = temp;
    }
}

/* --- INFIX TO POSTFIX --- */
void infixToPostfix(char* infix, char* output) {
    int i = 0, j = 0;
    while (infix[i] != '\0') {
        char c = infix[i];
        if (isalnum(c)) output[j++] = c;
        else if (c == '(') push(c);
        else if (c == ')') {
            while (!isEmpty() && peek() != '(') output[j++] = pop();
            pop();
        } else {
            while (!isEmpty() && precedence(peek()) >= precedence(c)) output[j++] = pop();
            push(c);
        }
        i++;
    }
    while (!isEmpty()) output[j++] = pop();
    output[j] = '\0';
}

/* --- INFIX TO PREFIX --- */
void infixToPrefix(char* infix, char* output) {
    reverse(infix);
    for (int i = 0; infix[i] != '\0'; i++) {
        if (infix[i] == '(') infix[i] = ')';
        else if (infix[i] == ')') infix[i] = '(';
    }
    char temp[100];
    infixToPostfix(infix, temp);
    reverse(temp);
    strcpy(output, temp);
}

int main() {
    char infix[100], postfix[100], prefix[100];

    printf("--- DLL STACK ---\n");
    printf("Enter Infix: ");
    scanf("%s", infix);

    char infixCopy[100];
    strcpy(infixCopy, infix);

    top = NULL;
    infixToPostfix(infix, postfix);
    printf("Postfix: %s\n", postfix);

    top = NULL;
    infixToPrefix(infixCopy, prefix);
    printf("Prefix:  %s\n", prefix);

    return 0;
}`,

      code8: `#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/* --- CSLL NODE --- */
typedef struct Node {
    char data;
    struct Node* next;
} Node;

Node* top = NULL;

/* --- CSLL STACK OPERATIONS --- */
int isEmpty() { return top == NULL; }

void push(char c) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = c;
    if (isEmpty()) {
        newNode->next = newNode;
        top = newNode;
    } else {
        Node* tail = top;
        while (tail->next != top) tail = tail->next;
        newNode->next = top;
        tail->next = newNode;
        top = newNode;
    }
}

char pop() {
    if (isEmpty()) return -1;
    char val = top->data;
    if (top->next == top) {
        free(top);
        top = NULL;
    } else {
        Node* tail = top;
        while (tail->next != top) tail = tail->next;
        Node* temp = top;
        top = top->next;
        tail->next = top;
        free(temp);
    }
    return val;
}

char peek() { return isEmpty() ? -1 : top->data; }

/* --- CONVERSION HELPERS --- */
int precedence(char c) {
    if (c == '^') return 3;
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return 0;
}

void reverse(char* exp) {
    int len = strlen(exp);
    for (int i = 0; i < len / 2; i++) {
        char temp = exp[i];
        exp[i] = exp[len - i - 1];
        exp[len - i - 1] = temp;
    }
}

/* --- INFIX TO POSTFIX --- */
void infixToPostfix(char* infix, char* output) {
    int i = 0, j = 0;
    while (infix[i] != '\0') {
        char c = infix[i];
        if (isalnum(c)) output[j++] = c;
        else if (c == '(') push(c);
        else if (c == ')') {
            while (!isEmpty() && peek() != '(') output[j++] = pop();
            pop(); 
        } else {
            while (!isEmpty() && precedence(peek()) >= precedence(c)) output[j++] = pop();
            push(c);
        }
        i++;
    }
    while (!isEmpty()) output[j++] = pop();
    output[j] = '\0';
}

/* --- INFIX TO PREFIX --- */
void infixToPrefix(char* infix, char* output) {
    reverse(infix);
    for (int i = 0; infix[i] != '\0'; i++) {
        if (infix[i] == '(') infix[i] = ')';
        else if (infix[i] == ')') infix[i] = '(';
    }
    char temp[100];
    infixToPostfix(infix, temp);
    reverse(temp);
    strcpy(output, temp);
}

int main() {
    char infix[100], postfix[100], prefix[100];
    
    printf("--- CSLL STACK ---\n");
    printf("Enter Infix: ");
    scanf("%s", infix);

    char infixCopy[100];
    strcpy(infixCopy, infix);

    top = NULL;
    infixToPostfix(infix, postfix);
    printf("Postfix: %s\n", postfix);

    top = NULL;
    infixToPrefix(infixCopy, prefix);
    printf("Prefix:  %s\n", prefix);
    
    return 0;
}
    
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/* --- CDLL NODE --- */
typedef struct Node {
    char data;
    struct Node* next;
    struct Node* prev;
} Node;

Node* top = NULL;

/* --- CDLL STACK OPERATIONS --- */
int isEmpty() { return top == NULL; }

void push(char c) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = c;
    if (isEmpty()) {
        newNode->next = newNode;
        newNode->prev = newNode;
        top = newNode;
    } else {
        Node* tail = top->prev;
        newNode->next = top;
        newNode->prev = tail;
        tail->next = newNode;
        top->prev = newNode;
        top = newNode;
    }
}

char pop() {
    if (isEmpty()) return -1;
    char val = top->data;
    if (top->next == top) {
        free(top);
        top = NULL;
    } else {
        Node* tail = top->prev;
        Node* temp = top;
        top = top->next;
        top->prev = tail;
        tail->next = top;
        free(temp);
    }
    return val;
}

char peek() { return isEmpty() ? -1 : top->data; }

/* --- CONVERSION HELPERS --- */
int precedence(char c) {
    if (c == '^') return 3;
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return 0;
}

void reverse(char* exp) {
    int len = strlen(exp);
    for (int i = 0; i < len / 2; i++) {
        char temp = exp[i];
        exp[i] = exp[len - i - 1];
        exp[len - i - 1] = temp;
    }
}

/* --- INFIX TO POSTFIX --- */
void infixToPostfix(char* infix, char* output) {
    int i = 0, j = 0;
    while (infix[i] != '\0') {
        char c = infix[i];
        if (isalnum(c)) output[j++] = c;
        else if (c == '(') push(c);
        else if (c == ')') {
            while (!isEmpty() && peek() != '(') output[j++] = pop();
            pop(); 
        } else {
            while (!isEmpty() && precedence(peek()) >= precedence(c)) output[j++] = pop();
            push(c);
        }
        i++;
    }
    while (!isEmpty()) output[j++] = pop();
    output[j] = '\0';
}

/* --- INFIX TO PREFIX --- */
void infixToPrefix(char* infix, char* output) {
    reverse(infix);
    for (int i = 0; infix[i] != '\0'; i++) {
        if (infix[i] == '(') infix[i] = ')';
        else if (infix[i] == ')') infix[i] = '(';
    }
    char temp[100];
    infixToPostfix(infix, temp);
    reverse(temp);
    strcpy(output, temp);
}

int main() {
    char infix[100], postfix[100], prefix[100];
    
    printf("--- CDLL STACK ---\n");
    printf("Enter Infix: ");
    scanf("%s", infix);

    char infixCopy[100];
    strcpy(infixCopy, infix);

    top = NULL;
    infixToPostfix(infix, postfix);
    printf("Postfix: %s\n", postfix);

    top = NULL;
    infixToPrefix(infixCopy, prefix);
    printf("Prefix:  %s\n", prefix);
    
    return 0;
}`,

      code9: `#include <stdio.h>
#define MAX 100

/* --- Global Variables --- */
int stack[MAX];
int top = -1;

/* --- Operations --- */
int isEmpty() {
    return top == -1;
}

int isFull() {
    return top == MAX - 1;
}

void push(int x) {
    if (isFull()) {
        printf("Stack Overflow\n");
        return;
    }
    stack[++top] = x;
    printf("Pushed %d\n", x);

    // Print Stack
    printf("Stack: [ ");
    for(int i = 0; i <= top; i++) printf("%d ", stack[i]);
    printf("]\n");
}

int pop() {
    if (isEmpty()) {
        printf("Stack Underflow\n");
        return -1;
    }
    int val = stack[top--];
    printf("Popped %d\n", val);

    // Print Stack
    printf("Stack: [ ");
    for(int i = 0; i <= top; i++) printf("%d ", stack[i]);
    printf("]\n");
    return val;
}

int peek() {
    if (isEmpty()) return -1;
    return stack[top];
}

int size() {
    return top + 1;
}

/* --- Main --- */
int main() {
    printf("--- Simple Array Stack ---\n");

    push(10);
    push(20);
    push(30);

    printf("Top Element: %d\n", peek());
    printf("Current Size: %d\n", size());

    pop();
    pop();

    return 0;
}`,
      code10:`#include <stdio.h>
#define MAX 100

/* --- Simple Stack Implementation --- */
int s1[MAX], top1 = -1;
int s2[MAX], top2 = -1;

void push1(int x) { s1[++top1] = x; }
int pop1() { return s1[top1--]; }
void push2(int x) { s2[++top2] = x; }
int pop2() { return s2[top2--]; }

/* --- Queue Operations --- */
void enqueue(int x) {
    push1(x);
    printf("Enqueued %d via Stack 1\n", x);
}

void dequeue() {
    if (top1 == -1 && top2 == -1) {
        printf("Queue Underflow\n");
        return;
    }

    // Move elements from s1 to s2 only if s2 is empty
    if (top2 == -1) {
        while (top1 != -1) {
            push2(pop1());
        }
    }

    printf("Dequeued %d from Stack 2\n", pop2());
}

void printQueue() {
    // Printing is tricky; show both stacks to visualize state
    printf("State -> S1: [ ");
    for(int i=0; i<=top1; i++) printf("%d ", s1[i]);
    printf("]  S2: [ ");
    for(int i=top2; i>=0; i--) printf("%d ", s2[i]); // S2 is reversed
    printf("]\n");
}

int main() {
    printf("--- QUEUE USING STACKS ---\n");
    enqueue(10); printQueue();
    enqueue(20); printQueue();
    enqueue(30); printQueue();

    printf("\n-- Dequeue Operation --\n");
    dequeue(); printQueue();
    dequeue(); printQueue();
    return 0;
}`,

      codea:`#include <stdio.h>
#define MAX 1000

/* --- Simple Integer Queue --- */
int queue[MAX];
int front = -1, rear = -1;

void enqueue(int x) {
    if (front == -1) front = 0;
    queue[++rear] = x;
}

int dequeue() {
    return queue[front++];
}

int isEmpty() {
    return front > rear;
}

void generateNumbers(int n) {
    printf("First %d numbers with digits 1, 2, 3:\n", n);

    // Step 1: Enqueue base numbers
    enqueue(1);
    enqueue(2);
    enqueue(3);

    int count = 0;

    while (count < n) {
        // Step 2: Dequeue and Print
        int x = dequeue();
        printf("%d ", x);
        count++;

        if (count >= n) break; // Optimization

        // Step 3: Append 1, 2, 3 and Enqueue children
        enqueue(x * 10 + 1);
        enqueue(x * 10 + 2);
        enqueue(x * 10 + 3);
    }
    printf("\n");
}

int main() {
    int n;
    printf("--- GENERATE N NUMBERS (1, 2, 3) ---\n");
    printf("Enter N: ");
    scanf("%d", &n);

    generateNumbers(n);
    return 0;
}find first n inetegrs 1 2 3 `,

      code11: `#include <stdio.h>
#include <stdlib.h>

typedef struct Node { int data; struct Node* next; } Node;
Node *f = NULL, *r = NULL; // Front, Rear

int isEmpty() { return f == NULL; }
int getF() { return isEmpty() ? -1 : f->data; }
int getR() { return isEmpty() ? -1 : r->data; }

int size() {
    int c = 0; Node* t = f;
    while(t) { c++; t = t->next; }
    return c;
}

void print() {
    Node* t = f; printf("Q: ");
    while(t) { printf("%d ", t->data); t = t->next; }
    printf("\n");
}

void enq(int x) {
    Node* n = (Node*)malloc(sizeof(Node));
    n->data = x; n->next = NULL;
    if(!r) f = r = n;
    else { r->next = n; r = n; }
    print();
}

void deq() {
    if(isEmpty()) return;
    Node* t = f; f = f->next;
    if(!f) r = NULL;
    free(t);
    print();
}

int main() {
    printf("SLL Queue:\n");
    enq(10); enq(20); enq(30);
    printf("F:%d R:%d Sz:%d\n", getF(), getR(), size());
    deq();
    return 0;
}`,

      code12: `#include <stdio.h>
#include <stdlib.h>

typedef struct Node { int data; struct Node* next; struct Node* prev;} Node;
Node *f = NULL, *r = NULL; // Front, Rear

int isEmpty() { return f == NULL; }
int getF() { return isEmpty() ? -1 : f->data; }
int getR() { return isEmpty() ? -1 : r->data; }

int size() {
    int c = 0; Node* t = f;
    while(t) { c++; t = t->next; }
    return c;
}

void print() {
    Node* t = f; printf("Q: ");
    while(t) { printf("%d ", t->data); t = t->next; }
    printf("\n");
}

void enq(int x) {
    Node* n = (Node*)malloc(sizeof(Node));
    n->data = x; n->next = NULL; n->prev = r;
    if(!r) f = r = n;
    else { r->next = n; r = n; }
    print();
}

void deq() {
    if(isEmpty()) return;
    Node* t = f; f = f->next;
    if(f){ f->prev=NULL;} else r = NULL;
    free(t);
    print();
}

int main() {
    printf("DLL Queue:\n");
    enq(10); enq(20); enq(30);
    printf("F:%d R:%d Sz:%d\n", getF(), getR(), size());
    deq();
    return 0;
}`,

      code13: `#include <stdio.h>
#include <stdlib.h>

typedef struct Node { int data; struct Node* next; } Node;
Node *f = NULL, *r = NULL;

int isEmpty() { return f == NULL; }
int getF() { return isEmpty() ? -1 : f->data; }
int getR() { return isEmpty() ? -1 : r->data; }

int size() {
    if(isEmpty()) return 0;
    int c = 0; Node* t = f;
    do { c++; t = t->next; } while(t != f);
    return c;
}

void print() {
    if(isEmpty()) { printf("Empty\n"); return; }
    Node* t = f; printf("Q: ");
    do { printf("%d ", t->data); t = t->next; } while(t != f);
    printf("\n");
}

void enq(int x) {
    Node* n = (Node*)malloc(sizeof(Node));
    n->data = x;
    if(!f) { f = r = n; r->next = f; }
    else { r->next = n; r = n; r->next = f; }
    print();
}

void deq() {
    if(isEmpty()) return;
    Node* t = f;
    if(f == r) { f = r = NULL; }
    else { f = f->next; r->next = f; }
    free(t);
    print();
}

int main() {
    printf("CSLL Queue:\n");
    enq(10); enq(20); enq(30);
    printf("F:%d R:%d Sz:%d\n", getF(), getR(), size());
    deq();
    return 0;
}`,

      code14: `#include <stdio.h>
#define MAX 100

int queue[MAX];
int front = -1, rear = -1;

/* --- Operations --- */
int isEmpty() {
    return (front == -1 || front > rear);
}

void size() {
    if (isEmpty()) printf("Queue Size: 0\n");
    else printf("Queue Size: %d\n", rear - front + 1);
}

void printQueue() {
    if (isEmpty()) { printf("Queue is Empty\n"); return; }
    printf("Queue: [ ");
    for (int i = front; i <= rear; i++) {
        printf("%d ", queue[i]);
    }
    printf("]\n");
}

void enqueue(int x) {
    if (rear == MAX - 1) { printf("Queue Overflow\n"); return; }
    if (front == -1) front = 0;
    queue[++rear] = x;
    printf("Enqueued %d. ", x);
    printQueue();
}

void dequeue() {
    if (isEmpty()) { printf("Queue Underflow\n"); return; }
    printf("Dequeued %d. ", queue[front++]);
    if (front > rear) front = rear = -1; // Reset if empty
    printQueue();
}

void getFront() {
    if (isEmpty()) printf("Queue Empty\n");
    else printf("Front Element: %d\n", queue[front]);
}

void getRear() {
    if (isEmpty()) printf("Queue Empty\n");
    else printf("Rear Element: %d\n", queue[rear]);
}

int main() {
    printf("--- QUEUE USING ARRAY ---\n");
    enqueue(10);
    enqueue(20);
    enqueue(30);
    getFront();
    getRear();
    size();
    dequeue();
    return 0;
} `,

      code15: `#include <stdio.h>
#include <stdlib.h>

/* --- i) Creation (Node Structure) --- */
typedef struct Node {
    int data;
    struct Node *left, *right;
} Node;

Node* create(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

/* --- ii) Find Size (Total Nodes) --- */
int getSize(Node* root) {
    if (!root) return 0;
    return 1 + getSize(root->left) + getSize(root->right);
}

/* --- iii) Check if Value Exists --- */
int search(Node* root, int val) {
    if (!root) return 0;
    if (root->data == val) return 1;
    return search(root->left, val) || search(root->right, val);
}

/* --- iv) Preorder Traversal (Root -> Left -> Right) --- */
void preorder(Node* root) {
    if (!root) return;
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}

/* --- v) Inorder Traversal (Left -> Root -> Right) --- */
void inorder(Node* root) {
    if (!root) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

/* --- vi) Postorder Traversal (Left -> Right -> Root) --- */
void postorder(Node* root) {
    if (!root) return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}

/* --- vii) Level Order Traversal (BFS) --- */
void levelOrder(Node* root) {
    if (!root) return;
    Node* queue[100]; // Simple Queue
    int front = 0, rear = 0;

    queue[rear++] = root; // Enqueue

    while (front < rear) {
        Node* curr = queue[front++]; // Dequeue
        printf("%d ", curr->data);

        if (curr->left) queue[rear++] = curr->left;
        if (curr->right) queue[rear++] = curr->right;
    }
}

/* --- viii) Height of Tree --- */
int height(Node* root) {
    if (!root) return 0;
    int l = height(root->left);
    int r = height(root->right);
    return (l > r ? l : r) + 1;
}

/* --- ix) Sum of all Nodes --- */
int sumNodes(Node* root) {
    if (!root) return 0;
    return root->data + sumNodes(root->left) + sumNodes(root->right);
}

/* Helper to check if leaf */
int isLeaf(Node* node) {
    return (node && !node->left && !node->right);
}

/* --- x) Sum of Left Leaves --- */
int sumLeftLeaves(Node* root) {
    if (!root) return 0;
    int sum = 0;
    if (isLeaf(root->left)) sum += root->left->data;
    else sum += sumLeftLeaves(root->left);

    sum += sumLeftLeaves(root->right);
    return sum;
}

/* --- xi) Sum of Right Leaves --- */
int sumRightLeaves(Node* root) {
    if (!root) return 0;
    int sum = 0;
    if (isLeaf(root->right)) sum += root->right->data;
    else sum += sumRightLeaves(root->right);

    sum += sumRightLeaves(root->left);
    return sum;
}

int main() {
    /* Tree Construction:
             1
           /   \
          2     3
         / \   /
        4   5 6
    */
    Node* root = create(1);
    root->left = create(2);
    root->right = create(3);
    root->left->left = create(4);  // Left Leaf
    root->left->right = create(5); // Right Leaf
    root->right->left = create(6); // Left Leaf

    printf("1. Size: %d\n", getSize(root));
    printf("2. Search 5: %s\n", search(root, 5) ? "Found" : "Not Found");

    printf("3. Preorder: "); preorder(root); printf("\n");
    printf("4. Inorder: "); inorder(root); printf("\n");
    printf("5. Postorder: "); postorder(root); printf("\n");
    printf("6. Level Order: "); levelOrder(root); printf("\n");

    printf("7. Height: %d\n", height(root));
    printf("8. Sum All Nodes: %d\n", sumNodes(root));

    // Left Leaves: 4 and 6. Sum = 10
    printf("9. Sum Left Leaves: %d\n", sumLeftLeaves(root));

    // Right Leaves: 5. Sum = 5
    printf("10. Sum Right Leaves: %d\n", sumRightLeaves(root));

    return 0;
}`,

      code16: `#include <stdio.h>
#include <stdlib.h>

// 1. Define the Node
struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

// Helper function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

// 2. Insert After Function (The conversion logic)
void insertAfter(struct Node* prev_node, int new_data) {
    if (prev_node == NULL) {
        printf("Previous node cannot be NULL\n");
        return;
    }

    // Allocate memory
    struct Node* newNode = createNode(new_data);

    // Link new node to neighbors
    newNode->next = prev_node->next;
    newNode->prev = prev_node;

    // Link current neighbor back to new node
    if (prev_node->next != NULL) {
        prev_node->next->prev = newNode;
    }

    // Link previous node forward to new node
    prev_node->next = newNode;
}

// Helper to print list forward
void printList(struct Node* node) {
    printf("Traversal: ");
    while (node != NULL) {
        printf("%d <-> ", node->data);
        node = node->next;
    }
    printf("NULL\n");
}

int main() {
    // Initialize Head
    struct Node* head = createNode(10);

    // Insert 20 after 10
    insertAfter(head, 20);

    // Insert 30 after 20
    insertAfter(head->next, 30);

    printList(head);

    return 0;
}`,

      code17: `#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define V 7 // Requirement: At least 7 Nodes

// --- DATA STRUCTURES ---

// 1. Matrix Structure
int matrix[V][V] = {0};

// 2. ArrayList Structure (Dynamic Array)
typedef struct {
    int dest;
    int weight;
} Edge;

typedef struct {
    Edge* items;
    int count;
    int capacity;
} ArrayList;

// Structures for List Representations
ArrayList adjArray[V];      // iv-vi: Array of ArrayLists (Fixed size array)
ArrayList* adjVector;       // vii-ix: ArrayList of ArrayLists (Dynamic pointer)

// --- HELPER FUNCTIONS ---

// Initialize an ArrayList
void initList(ArrayList* list) {
    list->count = 0;
    list->capacity = 2;
    list->items = (Edge*)malloc(list->capacity * sizeof(Edge));
}

// Add to ArrayList (handles resizing)
void push(ArrayList* list, int dest, int w) {
    if (list->count == list->capacity) {
        list->capacity *= 2;
        list->items = (Edge*)realloc(list->items, list->capacity * sizeof(Edge));
    }
    list->items[list->count++] = (Edge){dest, w};
}

// Unified AddEdge for Operations (i) to (ix)
void addEdge(int u, int v, int w, bool directed) {
    // 1. Matrix (i, ii, iii)
    matrix[u][v] = w;
    if (!directed) matrix[v][u] = w;

    // 2. Array of ArrayLists (iv, v, vi)
    push(&adjArray[u], v, w);
    if (!directed) push(&adjArray[v], u, w);

    // 3. ArrayList of ArrayLists (vii, viii, ix)
    push(&adjVector[u], v, w);
    if (!directed) push(&adjVector[v], u, w);
}

// (x) BFS Traversal
void BFS(int start) {
    bool visited[V] = {false};
    int queue[V], front = 0, rear = 0;

    printf("\n(x) BFS Traversal: ");

    visited[start] = true;
    queue[rear++] = start;

    while (front < rear) {
        int u = queue[front++];
        printf("%d ", u);

        // Iterate using adjArray (or adjVector)
        for (int i = 0; i < adjArray[u].count; i++) {
            int v = adjArray[u].items[i].dest;
            if (!visited[v]) {
                visited[v] = true;
                queue[rear++] = v;
            }
        }
    }
    printf("\n");
}

int main() {
    // Init Memory
    adjVector = (ArrayList*)malloc(V * sizeof(ArrayList));
    for(int i=0; i<V; i++) { initList(&adjArray[i]); initList(&adjVector[i]); }

    // --- CREATE GRAPHS ---
    // Syntax: addEdge(u, v, weight, isDirected)

    // Undirected, Unweighted (i, iv, vii)
    addEdge(0, 1, 1, false);
    addEdge(0, 2, 1, false);

    // Directed, Unweighted (ii, v, viii)
    addEdge(1, 3, 1, true);
    addEdge(1, 4, 1, true);

    // Directed, Weighted (iii, vi, ix)
    addEdge(2, 5, 10, true);
    addEdge(2, 6, 20, true);

    // Connect rest for BFS
    addEdge(3, 5, 1, true);
    addEdge(4, 6, 1, true);

    // Print Sample of Matrix (i)
    printf("Adj Matrix (Row 2): ");
    for(int i=0; i<V; i++) printf("%d ", matrix[2][i]);

    // Print Sample of List (vi)
    printf("\nAdj List (Node 2): ");
    for(int i=0; i<adjArray[2].count; i++)
        printf("->%d(w:%d) ", adjArray[2].items[i].dest, adjArray[2].items[i].weight);

    // Execute BFS
    BFS(0);

    return 0;
}`,

      code18: `#include <stdio.h>
#include <stdbool.h>

#define V 7 // Total Nodes

// Global Graph Structures
int adj[V][V] = {0}; 
bool visited[V] = {false};

// (i) Depth First Search Algorithm (Recursive)
void DFS(int u) {
    visited[u] = true;
    printf("%d ", u); // Process the node

    for (int v = 0; v < V; v++) {
        // If edge exists (1) and not visited
        if (adj[u][v] == 1 && !visited[v]) {
            DFS(v);
        }
    }
}

// Helper to add undirected edge
void addEdge(int u, int v) {
    adj[u][v] = 1;
    adj[v][u] = 1;
}

int main() {
    // Creating a Disconnected Graph with 3 Components
    // Component 1: 0-1-2
    addEdge(0, 1); addEdge(1, 2);
    
    // Component 2: 3-4
    addEdge(3, 4);

    // Component 3: 5-6 (Disconnected from others)
    addEdge(5, 6);

    // (ii) Find Number of Connected Components
    int componentCount = 0;
    
    printf("Connected Components found:\n");
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            componentCount++;
            printf("Component %d: { ", componentCount);
            DFS(i); // Start traversal for this component
            printf("}\n");
        }
    }

    printf("\nTotal Connected Components: %d\n", componentCount);

    return 0;
}`,

      code19: `#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define TABLE_SIZE 1009 // Small prime number for hashing

// 1. Hashmap Entry Structure
typedef struct {
    int key;
    int value; // Frequency
    bool used; // To check if slot is occupied
} HashEntry;

HashEntry hashMap[TABLE_SIZE];

// Simple Hash Function
int hash(int key) {
    return abs(key) % TABLE_SIZE;
}

// 2. Insert or Increment Frequency
void put(int key) {
    int idx = hash(key);
    
    // Linear Probing: Find empty slot or existing key
    while (hashMap[idx].used) {
        if (hashMap[idx].key == key) {
            hashMap[idx].value++; // Key found, increment count
            return;
        }
        idx = (idx + 1) % TABLE_SIZE; // Move to next slot
    }

    // Insert new key
    hashMap[idx].key = key;
    hashMap[idx].value = 1;
    hashMap[idx].used = true;
}

// 3. Get Frequency
int get(int key) {
    int idx = hash(key);
    int startIdx = idx;

    while (hashMap[idx].used) {
        if (hashMap[idx].key == key) {
            return hashMap[idx].value;
        }
        idx = (idx + 1) % TABLE_SIZE;
        if (idx == startIdx) break; // Full cycle, not found
    }
    return 0; // Not found
}

// 4. Main Logic: Returns dynamic array (ArrayList equivalent)
int* getFrequencies(int A[], int sizeA, int Q[], int sizeQ) {
    // Fill Hashmap with Array A
    for (int i = 0; i < sizeA; i++) {
        put(A[i]);
    }

    // Create Result Array
    int* result = (int*)malloc(sizeQ * sizeof(int));

    // Query Hashmap with Array Q
    for (int i = 0; i < sizeQ; i++) {
        result[i] = get(Q[i]);
    }

    return result;
}

int main() {
    // Clear global hashmap (optional if static, but good practice)
    for(int i=0; i<TABLE_SIZE; i++) hashMap[i].used = false;

    int A[] = {1, 2, 2, 3, 1, 4, 1};
    int Q[] = {1, 2, 5}; // Frequencies should be: 1->3, 2->2, 5->0
    
    int sizeA = 7;
    int sizeQ = 3;

    int* freqs = getFrequencies(A, sizeA, Q, sizeQ);

    printf("Frequencies: ");
    for (int i = 0; i < sizeQ; i++) {
        printf("%d ", freqs[i]);
    }
    printf("\n");

    free(freqs);
    return 0;
}`
    };

    function copyCode(key) {
      navigator.clipboard.writeText(hiddenCodes[key]);
    }

  </script>

</body>
</html>
